Squelch is a Linux Security Module that restricts what filenames can be created
(e.g., it can prevent creation of filenames with control characters,
filenames beginning with dash, or filenames that are not UTF-8).

Squelch can be used to harden a system against attacks
that are based on creating unusual filenames to exploit
imperfectly-written programs and user commands.
Squelch enforces rules that many users follow anyway, so non-attackers
will typically not notice when it's enabled.
Squelch is a minor Linux Security Module, so it can be
included along with a major module like SELinux or AppArmor.

Many POSIX systems, including Linux, normally allow filenames to contain
any sequence of bytes other than / and \0 (pathnames are a sequence
of filenames) if the filesystem format allows it.
However, many users and developers presume that filenames
can't include control characters (like tab and newline), can't start with "-",
and are a sequence of valid UTF-8 characters (e.g., for display).
This difference between what users and developers expect, as compared
to reality, can lead to security vulnerabilities.
The Common Weakness Enumeration (CWE) includes 3 weakneses related to this
(CWE 78, CWE 73, and CWE 116). Examples of vulnerabilities from this
problem include CVE-2011-1155 (logrotate) and
CVE-2013-7085 (uscan in devscripts).
For a general discussion of the problem, see:
http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html

You should still write code that handles unusual filenames correctly,
because that makes your code portable.
However, it is not trivial to handle arbitrary filenames correctly; see:
http://www.dwheeler.com/essays/filenames-in-shell.html
Until all code correctly handles arbitrary filenames, and stays that way,
this hardening mechanism can be useful.

This module addresses three different cases, where
"privileged" means "has CAP_SYS_ADMIN":
1. A non-malicious unprivileged application is tricked by an
   attacker into creating a malicious filename. Later errors in some code
   (privileged or not) cause the filename to be misinterpreted and
   lead to an exploit.
2. A malicious untrusted user directly creates a malicious filename.
   Again, later errors in some code (privileged or not)
   cause the filename to be misinterpreted and lead to an exploit.
3. Like #1, but a *privileged* application
   is tricked into creating a malicious filename, which later leads to
   an exploit.  For this case, you need to prevent privileged processes
   from creating those filenames.  This module lets you decide if you
   want to prevent privileged processes from creating such filenames.

This module only prevents *creating* filenames with certain
characteristics within currently-mounted filesystems.
It makes no attempt to counter unusual filenames at mount time.
This is still useful, since in many systems it's not possible
to mount untrusted filesystems.  A future version might add such
checking as an option.
